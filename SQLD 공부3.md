# SQLD 공부

## 1과목 데이터 모델링의 이해 (데이터 모델과 성능)


#### 1. 정규화와 성능

+ **성능 데이터 모델링의 개요**
  
  + 성능 데이터 모델링 : 분석/설계 단계부터 데이터베이스 성능을 고려한 데이터 모델링을 수행하는 기법.
  
  + 성능 데이터 모델링 수행 시점 : 분석/설계 단계부터 성능에 대한 데이터 모델을 설계하지 않으면 시간이 지날수록 성능 개선의 비용 증가.
    
  
  + 성능 데이터 모델링의 수행절차
    
    1.  데이터 모델링을 할 때 정규화를 정확하게 수행한다.
    
    2. 데이터베이스의 용량산정(현재용량과 예상증가량) 수행한다.
    
    3. 트랜잭션의 유형을 파악한다.
    
    4. 용량과 트랜잭션의 유형에 따라 반정규화 수행한다.
    
    5. 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행한다.
    
    6. 성능관점에서 데이터 모델을 검증한다.



+ **데이터베이스 정규화(DB Normalization)**
  
  + 정규화(DB Normalization)의 개념
    
    + 일정한 규칙에 따라 변형하여 이용하기 쉽게 만드는 일.
    
    + 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법.
    
    + 데이터의 중복을 제거하고 데이터 모델의 독립성을 확보.
    
    + 데이터 이상현상(Abnormality)을 줄이기 위한 데이터베이스 설계 기법.
    
    + 엔터티를 상세화하는 과정으로 논리 데이터 모델링 수행 시점에서 고려.
    
    
  
  + 이상현상(Abnormality) 종류
    
    | 종류                              | 설명                                     |
    | ------------------------------- | -------------------------------------- |
    | 삽입이상<br>(Insertion Abnormality) | 행(row) 삽입 시 지정되지 않은 속성 값이 NULL을 가지는 경우 |
    | 갱신이상<br>(Update Abnormality)    | 데이터 갱신 시 일부분의 데이터만 갱신되어 일관성 유지가 안되는 경우 |
    | 삭제이상<br>(Delete Abnormality)    | 행(row) 삭제 시 원하지 않는 연쇄 삭제가 발생하는 현상      |
    
  
  + 함수적 종속성
    
    + X값에 따라 Y값이 달라지는 경우, Y는 X에 대해서 함수적 종속 관계를 가진다.<br>(이때 X를 결정자, Y를 종속자라고 함.)
    
    + 정규화는 함수의 종속성에 근거한다.
    
    
  
  + 정규화 단계
    
    | 종류                               | 설명                                                                                                 |
    | -------------------------------- | -------------------------------------------------------------------------------------------------- |
    | 제1정규화                            | -**속성의 원자성**을 확보한다.<br>-기본키(Primary Key)를 설정한다.                                                    |
    | 제2정규화                            | -기본키가 2개 이상의 속성으로 이루어진 경우, **부분 함수 종속성**을 제거(분해)한다.                                                |
    | 제3정규화                            | -기본키를 제외한 컬럼 간에 종속성을 제거한다.<br>-**이행 함수 종속성**을 제거한다.<br>(기본키가 아닌 일반 컬럼들을 참조하는 경우를 이행 함수 종속성이라고 한다.) |
    | BCNF<br>(Boyce-Codd Normal Form) | -기본키를 제외하고 후보키가 있는 경우, 후보키가 기본키를 종속시키면서 분해한다.<br>-**결정자 함수 종속성**을 제거하는 단계<br>-강한 제3정규화             |
    | 제4정규화                            | -여러 컬럼들이 하나의 컬럼을 종속시키는 경우 분해하여 **다중값 종속성**을 제거한다.                                                  |
    | 제5정규화                            | -**조인**에 의해서 종속성이 발생되는 경우 분해한다.                                                                    |



#### 2. 반정규화와 성능


+ **반정규화(De-Normalization)의 개념**
  
  + 정규화된 데이터 모델을 시스템의 성능 향상, 개발 및 운영의 단순화를 위해 분리, 중복, 통합 등을 수행하는 데이터 모델링의 기법이다.
  
  + 조회 속도를 향상시키지만, 데이터 모델의 유연성은 낮아진다.
  
  + 정규화 입력 시 입력, 수정, 삭제 성능이 향상. 반정규화 시 조인 성능이 향상된다.
  
  + 비정규화는 정규화를 수행하지 않음을 의미.



+ **반정규화(De-Normalization)를 수행하는 경우**
  
  + 정규화에 충실하여 종속성, 활용성은 향상되지만 수행 속도가 느려지는 경우
  
  + 다량의 범위를 자주 처리해야하는 경우(범위를 줄이지 않으면 성능을 보장할 수 없는 경우)
  
  + 특정 범위의 데이터만 자주 처리하는 경우
  
  + 요약/집계 정보가 자주 요구되는 경우



+ **반정규화(De-Normalization) 절차**
  
  1. 반정규화 대상조사
  
  | 방법          | 내용                                                       |
  | ----------- | -------------------------------------------------------- |
  | 대량의 범위처리 조사 | -대량의 데이터 범위를 자주 처리하는지 확인<br>-범위를 줄이지 않으면 성능을 보장할 수 없는 경우 |
  | 범위처리 빈도수 조사 | 일정한 범위를 조회하는 프로세스가 많은지 확인                                |
  | 통계성 프로세스 조사 | 통계 정보를 필요로 하는 프로세스가 있는지 확인                               |
  | 테이블 조인 개수   | 조인 개수가 많은지 확인<br>(지나치게 많은 조인이 있으면 데이터를 조회하는 작업이 어려움.)    |
  
  
  2. 다른방법 유도
  
  | 방법          | 설명                                                  |
  | ----------- | --------------------------------------------------- |
  | 응용애플리케이션    | 응용 메모리 영역에서 데이터를 캐시 처리                              |
  | 클러스터링 적용    | 클러스터링 팩터에 의해 저장방식을 다르게 적용<br>(조회가 대부분인 경우 클러스터링 적용) |
  | 뷰(VIEW) 테이블 | 지나치게 많은 조인이 있어 데이터 조회 작업이 어려운 경우 성능을 고려한 뷰 생성       |
  | 인덱스의 조정     | 인덱스 변경 및 생성                                         |

  
  3. 반정규화 적용
  
  | 방법       | 설명                                                                  |
  | -------- | ------------------------------------------------------------------- |
  | 테이블 반정규화 | 테이블 병합, 분할, 추가                                                      |
  | 속성의 반정규화 | 파생 컬럼 추가, 응용시스템 오작동을 위한 컬럼 추가, 이력 테이블 컬럼 추가, PK에 의한 컬럼 추가, 중복 컬럼 추가 |
  | 관계의 반정규회 | 중복 관계 추가                                                            |



+ **반정규화 기법**
  
  + 테이블 반정규화
    
    1. 테이블 병합
  
    | 기법      | 내용                   |
    | ------- | -------------------- |
    | 1:1 관계  | 1:1 관계를 통합하여 성능 향상   |
    | 1:M 관계  | 1:M 관계를 통합하여 성능 향상   |
    | 슈퍼/서브타입 | 슈퍼/서브 관계를 통합하여 성능 향상 |
    
  
    2. 테이블분할
     
    | 기법   | 내용                                                                             |
    | ---- | ------------------------------------------------------------------------------ |
    | 수직분할 | 컬럼 단위 테이블을 디스크 I/O를 분산 처리 하기 위해 테이블을 1:1로 분리하여 성능 향상                           |
    | 수평분할 | row단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상시키기 위해 row단위로 테이블 쪼갬 |
    
  
    3. 테이블추가
     
    | 기법       | 내용                                                                   |
    | -------- | -------------------------------------------------------------------- |
    | 중복테이블 추가 | 다른 업무이거나 서버가 다른 경우 동일한 테이블 구조를 중복하여 원격 조인을 제거하여 성능 향상                |
    | 통계테이블 추가 | SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능 향상                              |
    | 이력테이블 추가 | 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재시켜 성능 향상                  |
    | 부분테이블 추가 | 자주 이용하는 집중화된 컬럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 컬럼들을 모아놓은 별도의 반정규화된 테이블 생성 |

    
    
  + 컬럼의 반정규화
    
    | 반정규화 기법             | 내용                                                                                                  |
    | ------------------- | --------------------------------------------------------------------------------------------------- |
    | 중복컬럼 추가             | 조인에 의해 처리할 때 성능 저하를 예방하기 위해(즉, 조인을 감소시키기 위해) 중복된 컬럼을 위치시킴                                           |
    | 파생컬럼 추가             | 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능 저하를 위해 미리 값을 계산하여 컬럼에 보관                                              |
    | 이력테이블 컬럼추가          | 대량의 이력테이블을 처리할 때 불특정 조회나 최근 값을 조회할 때 나타날 수 있는 성능 저하를 예방하기 위해 이력테이블에 기능성 컬럼(최근값 여부, 시작과 종료일자 등)을 추가함 |
    | PK에 의한 컬럼 추가        | -복합의미를 갖는 PK를 단일 속성으로 구성했을 때 발생<br>-PK안에서 특정 값을 별도로 조회하는 경우 성능 저하가 발생할 수 있어 일반 속성으로 포함              |
    | 응용시스템 오작동을 위한 컬럼 추가 | -업무적으로 의미가 없지만 사용자의 실수로 원래 값으로 복구하기 원하는 경우 이전 데이터를 임시로 중복하여 보관하는 방법                                 |
    
  
  + 관계의 반정규화
    
    + 중복관계 추가 : 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만 이 때 발생할 수 있는 성능 저하를 예방하기 위해 추가적인 관계를 맺는 방법
  
  



#### 3. 대용량 데이터에 따른 성능


+ **대용량 데이터의 성능 저하 원인**
  
  + 데이터의 양이 많은 경우
  
  + 컬럼의 수가 많은 경우
  
  + 로우 체이닝(Row Chaining), 로우 마이그레이션(Row Migration) 현상
    
    
    + 로우 체이닝(Row Chaining)
      
      + 데이터 저장 시 공간이 부족하여 발생
      
      + 로우의 길이가 너무 길어 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 검색하게 되므로 성능 감소
      
      + 해결방법 : 블록의 크기를 크게 하는 것
        
    
    + 로우 마이그레이션(Row Migration)
      
      + 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식
      
      + 원래 정보의 위치를 저장하고 실제 데이터는 다른 블록에 저장됨<br>->검색 시, 원래 블록에서 주소를 먼저 읽고 다른 블록을 찾으므로 성능이 감소됨.



+ **대용량 데이터의 성능 향상 방법**
  
  + 파티셔닝(Partitioning) -> 데이터가 많을 때
    
    | 기법                                 | 설명                                                                                                          |
    | ---------------------------------- | ----------------------------------------------------------------------------------------------------------- |
    | 레인지 파티셔닝<br>(Range Partition)      | -데이터 값의 범위를 기준으로 파티션을 수행하기 때문에 데이터 보관주기에 따라 데이터를 쉽게 지우는 것이 가능하여 데이터 관리가 용이.<br>-데이터가균등하게 파티션에 들어가지 않는 것이 단점 |
    | 리스트 파티셔닝<br>(List Partition)       | -데이터를 특정값에 따라 파티셔닝<br>-데이터 보관주기에 따라 쉽게 삭제하는 것은 불가능                                                          |
    | 해시 파티셔닝<br>(Hash Partition)        | -해시함수가 사용되어 테이블마다 값이 균등하게 분포<br>-데이터 보관주기에 따라 쉽게 삭제하는 것은 불가능<br>-데이터가 정확하게 어떻게 들어갔는지 알 수 없어 관리가 어려움         |
    | 컴포지트 파티셔닝<br>(Composite Partition) | -레인지 파티셔닝, 리스트 파티셔닝, 해시 파티셔닝 중 2개 이상의 파티셔닝을 결합하는 방법                                                         |
    
  
  + 테이블 분할(수평/수직 분할의 절차) -> 컬럼이 많을 때
    
    + 데이터 모델링을 완성한다.
    
    + 데이터베이스 용량산정을 한다.
    
    + 대량 데이터가 처리되는 테이블에 대해서 트랜잭션 처리 패턴 분석.
    
    + 칼럼 단위/로우단위로 집중화 된 처리가 발생하는비 분석하여 집중화된 단위로 테이블을 분석하는 것을 검토한다.





#### 4. DB 구조와 성능


+ **슈퍼/서브타입 데이터 모델의 개요**
  
  + 업무를 구성하는 데이터를 공통과 차이점의 특징을 고려해 효과적으로 표현하는 논리적 모델
  
  + 공통의 부분 -> 슈퍼타입
  
  + 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성 -> 서브타입



+ **슈퍼/서브타입 데이터 모델의 변환 방법**
  
  + One to One Type
    
    + 슈퍼타입과 서브타입 각각에 업무 트랜잭션이 독립적으로 발생하는 경우 사용
    
    + 개별 트랜잭션에 맞게 테이블 생성함으로써 I/O를 줄일 수 있다.
    
    + 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합하여 변화하면 불필요하게 많은 양의 데이터가 집적되어 성능 저하.
    
    + 테이블 수가 많아서 조인이 많이 발생하고 관리가 어려움.

  
  + Plus Type
    
    + 슈퍼 + 서브타입에 대해 발생되는 트랜잭션에 대해서는 Plus Type(슈퍼 + 서브타입) 테이블로 변환.
    
    + 슈퍼타입을 각 서브타입에 필요한 속성만 통합하므로써 I/O를 줄일 수 있음.
    
    + 조인이 많이 발생. 서브타입이 많은 경우 관리가 어려움.
    
    + 슈퍼타입과 서브타입을 함께 처리하는데 개별로 유지하면 조인에 의해 성능 저하.
      
  
  + Single Type
    
    + 전체를 하나의 테이블로 통합.
    
    + 관리 용이. 조인이 줄어들어 성능 향상.
    
    + 다수의 속성을 하나의 테이블에 저장하기 때문에 I/O 효율이 좋지 않음.
    
    + 서브타입 간에 조인이 다수 발생할 수 있어서 서브타입이 다수인 경우 관리가 어려움.



+ **인덱스 특성을 고려한 PK/FK 데이터베이스 성능 향상**
  
  | 고려사항    | 설명                                                                                                                      |
  | ------- | ----------------------------------------------------------------------------------------------------------------------- |
  | PK(기본키) | -PK 제약조건을 구현하기 위해 Unique 인덱스 사용<br>-복합 컬럼으로 구성된 PK에서 등치조건(=)이나 범위조건(>,<,between)을 사용하는 컬럼을 선행 컬럼으로 정해야 인덱스를 효율적으로 이용 가능 |
  | FK(외래키) | -FK 속성에 기본정책으로 인덱스를 생성하고, 업무적으로 자주 활용되지 않는 경우에 인덱스 삭제 고려.                                                               |





#### 5.분산DB 데이터에 따른 성능

+ **분산데이터베이스의 개념**
  
  + 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역, 여러 노드로 위치시켜 사용성, 성능 등을 극대화시킨 데이터베이스.



+ **분산 데이터베이스의 투명성(Transparency)**
  
  |             | 설명                                                                                                                                     |
  | ----------- | -------------------------------------------------------------------------------------------------------------------------------------- |
  | 분할 투명성(단편화) | 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장<br>(사용자가 데이터가 분할되어 있다는 사실을 알 필요 없다.)                                              |
  | 위치 투명성      | 사용하려는 데이터의 저장 장소 명시 불필요<br>(사용자가 특정 데이터가 분할되어 있다는 사실을 아는 경우, 분할된 데이터의 위치 정보를 알 필요 없다.)                                                 |
  | 지역사상 투명성    | 지역 DBMS와 물리적 DB 사이의 Mapping 보장, 각 지역 시스템 이름과 무관한 이름 사용 가능<br>(사용자가 데이터의 이름과 위치를 특정할 수 있는 경우, 다른 지역에 있다는 사실을 알 수 있다.)                   |
  | 중복 투명성      | DB 객체가 여러 site에 중복되어있는지 알 필요가 없는 성질<br>(데이터가 여러 지역 서버에 중복되어 존재하는 지 알 필요 없다.)                                                           |
  | 장애 투명성      | 구성요소의 장애에 무관한 Transaction의 원자성 유지<br>(특정 서버에서 데이터 작업을 하다가 서버가 나간 경우, 자동으로 다른 서버에 존재하는 같은 데이터로 작업 가능. 사용자가 장애 사실을 알 필요 없다.)             |
  | 병행 투명성      | 다수 Transaction 동시 수행 시 일관성 유지, Time Stamp, 분산 2단계 Locking을 이용 구현<br>(사용자가 데이터 작업 시 다른 사용자가 작업하고 있더라도 자신이 독점적으로 데이터 작업하고 있다고 느끼도록 해야함.) |



+ **분산 데이터베이스의 장점/단점**
  
  + 장점
    
    -지역 자치성
    
    -점증적 시스템 용량의 확정
    
    -신뢰성
    
    -가용성
    
    -융통성
    
    -빠른 응답속도
    
    -지역 사용자의 요구 수용 증대
    
  
  + 단점
    
    -오류의 잠재성 증가
    
    -처리 비용의 증가
    
    -데이터 무결성에 대한 위협
    
    -불규칙한 응답속도
    
    -데이터 보안성 떨어짐



+ **분산 데이터베이스 설계를 고려해야하는 경우**
  
  + 성능이 중요한 사이트
  
  + 공통코드, 기준정보, 마스터 데이터 등에 대해 분산 환경을 구성하면 성능 향상
  
  + 실시간 동기화가 요구되지 않을 때, 거의 실시간의 업무특징을 가지고 있을 때
  
  + 특정 서버에 부하가 집중될 때 부하 분산
  
  + 백업 사이트를 구성할 때



   




