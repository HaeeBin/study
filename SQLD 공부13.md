# SQLD 공부

## 2과목 SQL 기본 및 활용 (SQL 최적화 기본 원리)

#### 1. 옵티마이저(Optimizer)와 실행계획

+ **옵티마이저(Optimizer)**
  
  + 사용자의 SQL문에 대해 최적의 실행 방법을 결정하는 것.



+ **SQL 최적화 과정**
  
  1. SQL Parshing : SQL문장을 이루는 개별 요소 분석
  
  2. Optimization : 일반적 쿼리로 변환, 비용 계산, 실행 계획 후보 선정
  
  3. Row-Source Generation : 실행계획을 실제 실행하는 코드로 포맷
  
  4. Execution : SQL 실행.



+ **옵티마이저 유형**
  
  | 유형                                   | 설명                                                           |
  | ------------------------------------ | ------------------------------------------------------------ |
  | 규칙기반 옵티마이저<br>(Rule Based Optimizer) | 우선순위를 기반으로 실행계획 생성                                           |
  | 비용기반 옵티마이저<br>(Cost Based Optimizer) | 통계 정보를 사용하여 예상 소요시간, 자원 사용량을 계산해 실행계획 선택<br>(기본적으로 사용하는 유형.) |



+ **규칙기반 옵티마이저(Rule Based Optimizer)**
  
  + 실행계획을 수립할 때 15개의 우선순위를 기준으로 수립.
  
  + 제일 높은 우선순위 : ROWID(행ID)사용.
  
  + 제일 낮은 우선순위 : 전체 테이블을 스캔하는 방식.



+ **비용기반 옵티마이저(Cost Based Optimizer)**
  
  + 통계 정보를 바탕으로 비용을 계산하는 방식이기 때문에 통계 정보가 없거나 부족할 경우 성능 저하가 발생할 수 있음.





+ **실행계획(Execution Plan)**
  
  + 옵티마이저의 실행계획은 SQL 성능에 중요한 역할.
  
  + 실제 처리 건수에 대해서는 알 수 없음.
  
  + 실행계획의 구성 요소
    
    | 구성요소   | 설명                             |
    | ------ | ------------------------------ |
    | 액세스 기법 | 테이블을 액세스할 때 사용하는 방법            |
    | 조인 순서  | 테이블 조인할 때 참조하는 테이블 순서          |
    | 조인 기법  | 테이블 조인할 때 사용하는 방법              |
    | 최적화 정보 | 단계별로 예상되는 비용 정보 (=질의 처리 예상 비용) |
    
    


#### 2. 인덱스(Index) 기본

+ **인덱스(Index) 개념**

  + 데이터베이스에서 검색 속도를 향상시키기 위해 사용하는 기능.
 
  +  삽입과 삭제 속도는 저하될 수 있다.
 
  +  Unique Index에는 NULL값이 포함될 수 있다.
 
  +  많은 데이터 삽입하는 경우,  인덱스 삭제하고 다시 생성하는 것이 좋다.
 
  +  B-TREE(주로 사용함), BITMAP 인덱스가 있다.
 

+ **장단점**

  | 장점 | 단점 |
  | ----- | ------- |
  | 검색속도가 빨라짐.<br>시스템 부하를 줄여서 성능 향상됨. | 추가적인 메모리 공간 필요.<br>테이블에 데이터가 많을 경우 인덱스 생성 기간이 오래걸림.<br>INSERT/UPDATE/DELETE와 같은 변경 작업 자주 발생시 성능 저하. |


+ **유형**

  + B-TREE(Balanced Tree) 인덱스
    
    + 루트 블록, 브랜치 블록, 리프 블록으로 구성.
   
    + 리프 블록 : 인덱스 키와 ROWID로 구성. 인덱스 키는 정렬되어 저장되어 있다.
   
    + 데이터의 10% 이하의 데이터 검색 시 유리.
   
    + 일치, 범위 검색에 유리.
   
      
   
  + BITMAP 인덱스
 
    + 비트를 이용해 컬럼 값 저장하고 비트맵으로 저장된다.
   
    + 읽기 위주의 대용량 데이터 웨어하우스(특히 OLAP) 환경에 적합.
   
    + OLTP 환경에 비트맵 인덱스 사용 불가.
   
    + 여러 인덱스 동시에 활용할 수 있다.
   



#### 3. 옵티마이저 조인(Optimizer Join)

+ **옵티마이저 조인 방식**

  | 방식 | 설명 |
  | ------ | ------------- |
  | Nested Loop Join | 선행 테이블에서 데이터 찾고 후행 테이블 조인 |
  | Sort Merge Join | 조인 컬럼을 기준으로 데이터를 정렬하여 조인 |
  | Hash Join | 해시 함수 이용해서 데이터 조인 |


+ **Nested Loop Join**

  + 선행 테이블의 크기가 작아야 데이터가 스캔되는 범위를 줄일 수 있다.
 
  + NL Join은 Random Access 발생함.
 
  + 대량의 데이터를 조인할 때 비효율적.
 

+ **Sort Merge Join**.

  + 동등, 비동등 조건에서 모두 사용 가능.
 
  + 정렬 데이터양이 많으면 성능이 떨어진다.
 
  + 인덱스가 없는 경우에도 사용 가능.
 

+ **Hah Join**

  + Sort Merge Join하기에 두 테이블이 너무 커서 부하가 클 때 사용.
 
  + 동등 조건에서만 사용 가능.
 
  + 삽입, 삭제, 탐색이 매우 빠름.
 
  + 결과 행의 수가 적은 선행 테이블을 사용하는 것이 좋음.
 

+ **조인 비교**

  | Nested Loop Join | Sort Merge Join | Hash Join |
  | ----------------- | ---------------- | --------------- |
  | EQUI Join, Non-EQUI Join 둘 다 사용 | EQUI Join, Non-EQUI Join 둘 다 사용 | EQUI Join에서만 사용 |
  |                                    | 대용량 테이블을 조인하는 경우 | 대용량 테이블 조인하는 경우 |
  | 크기가 작은 선행 테이블 사용 |                        | 크기가 작은 선행 테이블 사용 |
  | 인덱스가 있어서 NATURAL JOIN이 효율적일 때 유용 | 인덱스 유무에 영향 받지 않음 | 인덱스 필수 아님 |
  |                            | 해시 함수를 이용해 데이터 조인 | Sort Merge Join하기에 두 테이블이 너무 커서 부하가 클 때 사용 |
  | OLTP 목록 처리 업무에 사용 | DW 등 데이터 집계 업무에 사용 | DW 등 데이터 집계 업무에 사용 |

  

   
  
